package main

/*
# 실습: 반복문과 함수
함수와 반복문을 가지고 노는 방법으로서 제곱근 함수를 도입해봅시다
: x라는 숫자가 주어졌을 때, 우리는 z²이 x에 가장 가까운 숫자 z를 찾아낼 것입니다.
컴퓨터는 주로 x의 제곱근을 반복문을 사용해 연산합니다. 
어떠한 추측 값 z로부터 시작해, 우리는 z²가 x에 얼마나 가까운 가를 근거로 z의 더 좋은 값을 추정합니다.
```
z -= (z*z - x) / (2*z)
```
이러한 조정을 반복함으로써 우리가 최대한 실제 제곱근에 가까운 정답에 도달할 때까지 추측은 점점 더 정확해집니다.
주어진 func Sqrt 에 이것을 도입하십시오. 입력값이 어떻든 간에 z = 1이라는 괜찮은 가정에서 시작합니다. 
시작과 함께 계산을 10회 반복하고 그에 따른 각각의 z의 값을 출력하세요. 
당신이 x의 다양한 값(1, 2, 3, ...)에 얼마나 가까워지는 지 그리고 얼마나 빠르게 추측이 개선되는 지 보세요.
힌트: 실수값을 선언하고 초기화하는 방법 - 값에 소수점을 입력해주거나 변환식을 사용하세요.
```
z := 1.0
z := float64(1)
```
다음으로 한 번 변수가 변경되기를 멈추었거나 매우 작은 양만 변화만 존재할 경우 반복문의 조건을 변경하십시오. 
10회의 iteration보다 많은 지 적은 지 보십시오. z에 대한 초기 추측으로 x나 x/2 같은 다른 값들을 시도해보십시오. 
당신의 함수의 결과가 표준 라이브러리인 math.Sqrt의 결과에 얼마나 가까운가요?
(참고 : 알고리즘의 세부 사항에 관심이 있으신 분들을 위해:
위의 z² − x는 z²가 되어야할 값 (x)과 얼마나 차이나는 지를 나타내고, 2z로 나누는 것은 z²가 얼마나 빨리 변하는 지에 따라 z를 조정하기 위한 z²의 미분입니다. 
이 일반적인 접근 방식을 Newton's method라고합니다. 많은 함수에서도 잘 작동하지만 특히 제곱근에서는 잘 작동합니다.)
*/

import (
	"fmt"
)

func Sqrt(x float64) float64 {

}

func main()  {
	
}